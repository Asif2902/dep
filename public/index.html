<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MonBridgeDex - DEX Aggregator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            margin-bottom: 30px;
            text-align: center;
        }

        .header h1 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 2.5em;
        }

        .subtitle {
            color: #666;
            font-size: 1.1em;
        }

        .network-info {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .network-badge {
            background: #667eea;
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9em;
        }

        .wallet-section {
            background: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }

        .wallet-info {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            align-items: center;
        }

        .wallet-address {
            font-family: monospace;
            background: #f5f5f5;
            padding: 10px 15px;
            border-radius: 8px;
            color: #333;
        }

        .connect-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 8px;
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.3s;
        }

        .connect-btn:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .connect-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .tabs {
            background: white;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .tab-buttons {
            display: flex;
            background: #f5f5f5;
            border-bottom: 2px solid #e0e0e0;
        }

        .tab-button {
            flex: 1;
            padding: 15px 20px;
            border: none;
            background: transparent;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: 600;
            color: #666;
            transition: all 0.3s;
            border-bottom: 3px solid transparent;
        }

        .tab-button:hover {
            background: #eee;
        }

        .tab-button.active {
            color: #667eea;
            background: white;
            border-bottom: 3px solid #667eea;
        }

        .tab-content {
            display: none;
            padding: 30px;
        }

        .tab-content.active {
            display: block;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            color: #333;
            font-weight: 600;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1em;
            transition: border-color 0.3s;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #667eea;
        }

        .form-group small {
            display: block;
            margin-top: 5px;
            color: #666;
            font-size: 0.9em;
        }

        .btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s;
            width: 100%;
            margin-top: 10px;
        }

        .btn:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .btn-success {
            background: #28a745;
        }

        .btn-success:hover {
            background: #218838;
        }

        .btn-warning {
            background: #ffc107;
            color: #333;
        }

        .btn-warning:hover {
            background: #e0a800;
        }

        .btn-danger {
            background: #dc3545;
        }

        .btn-danger:hover {
            background: #c82333;
        }

        .message {
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            display: none;
        }

        .message.show {
            display: block;
        }

        .message.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .message.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .message.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .router-list {
            margin-top: 20px;
        }

        .router-item {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .router-address {
            font-family: monospace;
            flex: 1;
        }

        .router-item button {
            width: auto;
            margin-top: 0;
            margin-left: 10px;
        }

        .router-status {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: 600;
            margin-left: 10px;
        }

        .router-status.active {
            background: #d4edda;
            color: #155724;
        }

        .router-status.inactive {
            background: #f8d7da;
            color: #721c24;
        }

        .router-status.testing {
            background: #fff3cd;
            color: #856404;
        }

        .quote-card {
            background: #f8f9fa;
            border: 2px solid #667eea;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
        }

        .quote-row {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid #e0e0e0;
        }

        .quote-row:last-child {
            border-bottom: none;
        }

        .quote-label {
            font-weight: 600;
            color: #666;
        }

        .quote-value {
            font-family: monospace;
            color: #333;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .swap-flow {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 20px;
        }

        .step-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 15px;
            background: #f5f5f5;
            border-radius: 8px;
            border-left: 4px solid #ccc;
        }

        .step-indicator.active {
            border-left-color: #667eea;
            background: #e8ebff;
        }

        .step-indicator.completed {
            border-left-color: #28a745;
            background: #d4edda;
        }

        .step-number {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: #ccc;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }

        .step-indicator.active .step-number {
            background: #667eea;
        }

        .step-indicator.completed .step-number {
            background: #28a745;
        }

        .grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        @media (max-width: 768px) {
            .grid-2 {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üåâ MonBridgeDex</h1>
            <p class="subtitle">DEX Aggregator for Monad Network</p>
            <div class="network-info">
                <span class="network-badge" id="networkName">Not Connected</span>
                <span class="network-badge" id="contractAddress">Loading...</span>
            </div>
        </div>

        <div class="wallet-section">
            <div class="wallet-info">
                <div id="walletStatus">
                    <strong>Wallet:</strong> Not Connected
                </div>
            </div>
            <button class="connect-btn" id="connectBtn" onclick="connectWallet()">
                Connect Wallet
            </button>
        </div>

        <div class="tabs">
            <div class="tab-buttons">
                <button class="tab-button active" onclick="switchTab('swap')">
                    üîÑ Swap
                </button>
                <button class="tab-button" onclick="switchTab('routers')">
                    ‚öôÔ∏è Manage Routers
                </button>
                <button class="tab-button" onclick="switchTab('config')">
                    üéõÔ∏è Config
                </button>
            </div>

            <!-- SWAP TAB -->
            <div id="swap" class="tab-content active">
                <h2 style="color: #667eea; margin-bottom: 20px;">Execute Token Swap</h2>

                <div class="form-group">
                    <label>Token From (Address)</label>
                    <input type="text" id="tokenIn" placeholder="0x..." />
                    <small>Enter the token address you want to swap from</small>
                </div>

                <div class="form-group">
                    <label>Token To (Address)</label>
                    <input type="text" id="tokenOut" placeholder="0x..." />
                    <small>Enter the token address you want to receive</small>
                </div>

                <div class="form-group">
                    <label>Amount (in token units)</label>
                    <input type="text" id="amountIn" placeholder="1000000000000000000" />
                    <small>Amount in smallest unit (e.g., wei for 18 decimal tokens)</small>
                </div>

                <div class="form-group">
                    <label>Slippage Tolerance (%)</label>
                    <input type="number" id="slippage" value="0.5" step="0.1" min="0.1" max="50" />
                    <small>Maximum acceptable slippage (default: 0.5%)</small>
                </div>

                <button class="btn" onclick="getQuote()">
                    Get Best Quote
                </button>

                <div id="quoteResult"></div>
                <div id="swapFlow"></div>
                <div id="swapMessage" class="message"></div>
            </div>

            <!-- ROUTERS TAB -->
            <div id="routers" class="tab-content">
                <h2 style="color: #667eea; margin-bottom: 20px;">Router Management</h2>

                <div style="margin-bottom: 30px;">
                    <h3 style="margin-bottom: 15px;">Add New Router</h3>
                    <div class="form-group">
                        <label>Router Type</label>
                        <select id="routerType" onchange="toggleFactoryInput()">
                            <option value="v2">Uniswap V2</option>
                            <option value="v3">Uniswap V3</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Router Address</label>
                        <input type="text" id="newRouterAddress" placeholder="0x..." />
                    </div>
                    <div class="form-group" id="factoryInputGroup" style="display: none;">
                        <label>Factory Address (V3 only)</label>
                        <input type="text" id="newFactoryAddress" placeholder="0x..." />
                        <small>Required for Uniswap V3 routers</small>
                    </div>
                    <button class="btn" onclick="addRouter()">
                        Add Router
                    </button>
                </div>

                <div>
                    <h3 style="margin-bottom: 15px;">V2 Routers</h3>
                    <div id="v2RoutersList" class="router-list">
                        <p>Loading...</p>
                    </div>
                </div>

                <div style="margin-top: 30px;">
                    <h3 style="margin-bottom: 15px;">V3 Routers</h3>
                    <div id="v3RoutersList" class="router-list">
                        <p>Loading...</p>
                    </div>
                </div>

                <div style="margin-top: 30px; display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                    <button class="btn" onclick="testAllRouters()">
                        üîç Test All Routers
                    </button>
                    <button class="btn btn-danger" onclick="removeAllFailedRouters()">
                        üóëÔ∏è Remove All Failed Routers
                    </button>
                </div>

                <div id="routerMessage" class="message"></div>
            </div>

            <!-- CONFIG TAB -->
            <div id="config" class="tab-content">
                <h2 style="color: #667eea; margin-bottom: 20px;">Contract Configuration</h2>

                <div style="margin-top: 20px;">
                    <h3 style="margin-bottom: 15px;">Withdraw Collected Fees</h3>
                    <button class="btn btn-success" onclick="withdrawFees()">
                        Withdraw All Fees
                    </button>
                </div>

                <div style="margin-top: 30px;">
                    <h3 style="margin-bottom: 15px;">Contract Info</h3>
                    <div class="quote-card">
                        <div class="quote-row">
                            <span class="quote-label">Owner:</span>
                            <span class="quote-value" id="ownerAddress">Loading...</span>
                        </div>
                        <div class="quote-row">
                            <span class="quote-label">Current Fee:</span>
                            <span class="quote-value" id="currentFee">Loading...</span>
                        </div>
                        <div class="quote-row">
                            <span class="quote-label">WETH Address:</span>
                            <span class="quote-value" id="wethAddress">Loading...</span>
                        </div>
                    </div>
                </div>

                <div id="configMessage" class="message"></div>
            </div>
        </div>
    </div>

    <script>
        let provider;
        let signer;
        let contract;
        let userAddress;
        let contractConfig = {
            contractAddress: "0x1c25B561D112be73d5019B7e8521AAB1b7c58F55",
            chainId: 143,
            network: "monad"
        };
        let currentQuote = null;

        const ERC20_ABI = [
            "function approve(address spender, uint256 amount) external returns (bool)",
            "function allowance(address owner, address spender) external view returns (uint256)",
            "function decimals() external view returns (uint8)",
            "function symbol() external view returns (string)",
            "function balanceOf(address account) external view returns (uint256)"
        ];

        const CONTRACT_ABI = [
            "function addRouter(address _router) external",
            "function addV3Router(address _router, address _factory) external",
            "function removeRouter(address _router) external",
            "function removeV3Router(address _router) external",
            "function getRouters() external view returns (address[])",
            "function getV3Routers() external view returns (address[])",
            "function owner() external view returns (address)",
            "function WETH() external view returns (address)",
            "function FEE_DIVISOR() external view returns (uint256)",
            "function v3RouterToFactory(address) external view returns (address)",
            "function getBestSwapData(uint amountIn, address[] calldata path, bool supportFeeOnTransfer, uint16 userSlippageBPS) external view returns (tuple(uint8 swapType, uint8 routerType, address router, address[] path, uint24[] v3Fees, uint amountIn, uint amountOutMin, uint deadline, bool supportFeeOnTransfer))",
            "function execute(tuple(uint8 swapType, uint8 routerType, address router, address[] path, uint24[] v3Fees, uint amountIn, uint amountOutMin, uint deadline, bool supportFeeOnTransfer) swapData) external payable returns (uint)",
            "function withdrawFeesETH() external",
            "function withdrawFeesToken(address token) external",
            "function feeAccumulatedETH() external view returns (uint256)",
            "function v3FeeTiers(uint256) external view returns (uint24)"
        ];

        async function init() {
            try {
                document.getElementById('contractAddress').textContent = 
                    `Contract: ${contractConfig.contractAddress.slice(0, 6)}...${contractConfig.contractAddress.slice(-4)}`;

                // Initialize read-only contract with default provider for quotes
                const defaultProvider = new ethers.providers.JsonRpcProvider('https://rpc.monad.xyz');
                contract = new ethers.Contract(contractConfig.contractAddress, CONTRACT_ABI, defaultProvider);

                if (window.ethereum) {
                    provider = new ethers.providers.Web3Provider(window.ethereum);

                    window.ethereum.on('accountsChanged', handleAccountsChanged);
                    window.ethereum.on('chainChanged', () => window.location.reload());

                    const accounts = await provider.listAccounts();
                    if (accounts.length > 0) {
                        await connectWallet();
                    }
                }
            } catch (error) {
                console.error('Init error:', error);
                showMessage('swapMessage', 'Error initializing contract', 'error');
            }
        }

        async function connectWallet() {
            try {
                if (!window.ethereum) {
                    alert('Please install MetaMask!');
                    return;
                }

                const accounts = await window.ethereum.request({ 
                    method: 'eth_requestAccounts' 
                });

                userAddress = accounts[0];
                signer = provider.getSigner();
                // Rebind contract with signer for write operations
                contract = new ethers.Contract(contractConfig.contractAddress, CONTRACT_ABI, signer);

                const network = await provider.getNetwork();
                document.getElementById('networkName').textContent = 
                    network.chainId === 143 ? 'Monad Mainnet' : `Chain ID: ${network.chainId}`;

                document.getElementById('walletStatus').innerHTML = 
                    `<strong>Wallet:</strong> <span class="wallet-address">${userAddress.slice(0, 6)}...${userAddress.slice(-4)}</span>`;

                document.getElementById('connectBtn').textContent = 'Connected ‚úì';
                document.getElementById('connectBtn').disabled = true;

                await loadContractInfo();
                await loadRouters();

            } catch (error) {
                console.error('Connection error:', error);
                showMessage('swapMessage', 'Failed to connect wallet', 'error');
            }
        }

        function handleAccountsChanged(accounts) {
            if (accounts.length === 0) {
                location.reload();
            } else if (accounts[0] !== userAddress) {
                location.reload();
            }
        }

        async function loadContractInfo() {
            try {
                const owner = await contract.owner();
                const feeDivisor = await contract.FEE_DIVISOR();
                const weth = await contract.WETH();

                // FEE_DIVISOR of 1000 means 0.1% fee (1/1000)
                const feePercentage = (100 / feeDivisor.toNumber()).toFixed(2);

                document.getElementById('ownerAddress').textContent = owner;
                document.getElementById('currentFee').textContent = `1/${feeDivisor.toString()} (${feePercentage}%)`;
                document.getElementById('wethAddress').textContent = weth;

                console.log('Contract Info Loaded:');
                console.log('Owner:', owner);
                console.log('Fee Divisor:', feeDivisor.toString());
                console.log('Fee Percentage:', feePercentage + '%');
                console.log('WETH Address:', weth);
            } catch (error) {
                console.error('Error loading contract info:', error);
                document.getElementById('ownerAddress').textContent = 'Error loading';
                document.getElementById('currentFee').textContent = 'Error loading';
                document.getElementById('wethAddress').textContent = 'Error loading';
            }
        }

        function toggleFactoryInput() {
            const type = document.getElementById('routerType').value;
            const factoryGroup = document.getElementById('factoryInputGroup');
            factoryGroup.style.display = type === 'v3' ? 'block' : 'none';
        }

        async function loadRouters() {
            try {
                const v2Routers = await contract.getRouters();
                const v3Routers = await contract.getV3Routers();

                const v2List = document.getElementById('v2RoutersList');
                const v3List = document.getElementById('v3RoutersList');

                v2List.innerHTML = v2Routers.length === 0 ? 
                    '<p style="color: #666;">No V2 routers added</p>' : 
                    v2Routers.map(addr => `
                        <div class="router-item" id="v2-${addr}">
                            <div style="flex: 1;">
                                <span class="router-address">${addr}</span>
                                <span class="router-status" id="status-v2-${addr}">‚óè</span>
                            </div>
                            <div style="display: flex; gap: 10px;">
                                <button class="btn btn-warning" onclick="testRouter('v2', '${addr}')" style="width: auto; padding: 8px 16px;">Test</button>
                                <button class="btn btn-danger" onclick="confirmRemoveRouter('v2', '${addr}')" style="width: auto; padding: 8px 16px;">Remove</button>
                            </div>
                        </div>
                    `).join('');

                // Get factory addresses for V3 routers
                const v3WithFactories = await Promise.all(
                    v3Routers.map(async (addr) => {
                        const factory = await contract.v3RouterToFactory(addr);
                        return { router: addr, factory };
                    })
                );

                v3List.innerHTML = v3Routers.length === 0 ? 
                    '<p style="color: #666;">No V3 routers added</p>' : 
                    v3WithFactories.map(({ router, factory }) => `
                        <div class="router-item" id="v3-${router}">
                            <div style="flex: 1;">
                                <div class="router-address">${router}</div>
                                <small style="color: #666;">Factory: ${factory}</small>
                                <span class="router-status" id="status-v3-${router}">‚óè</span>
                            </div>
                            <div style="display: flex; gap: 10px;">
                                <button class="btn btn-warning" onclick="testRouter('v3', '${router}')" style="width: auto; padding: 8px 16px;">Test</button>
                                <button class="btn btn-danger" onclick="confirmRemoveRouter('v3', '${router}')" style="width: auto; padding: 8px 16px;">Remove</button>
                            </div>
                        </div>
                    `).join('');
            } catch (error) {
                console.error('Error loading routers:', error);
            }
        }

        async function addRouter() {
            const type = document.getElementById('routerType').value;
            const address = document.getElementById('newRouterAddress').value;

            if (!ethers.utils.isAddress(address)) {
                showMessage('routerMessage', 'Invalid router address', 'error');
                return;
            }

            let tx;
            try {
                showMessage('routerMessage', 'Adding router...', 'info');

                if (type === 'v2') {
                    tx = await contract.addRouter(address);
                } else {
                    const factoryAddress = document.getElementById('newFactoryAddress').value;
                    if (!ethers.utils.isAddress(factoryAddress)) {
                        showMessage('routerMessage', 'Invalid factory address for V3 router', 'error');
                        return;
                    }
                    tx = await contract.addV3Router(address, factoryAddress);
                }

                await tx.wait();
                showMessage('routerMessage', 'Router added successfully!', 'success');
                document.getElementById('newRouterAddress').value = '';
                document.getElementById('newFactoryAddress').value = '';
                await loadRouters();
            } catch (error) {
                console.error('Error adding router:', error);
                showMessage('routerMessage', `Error: ${error.message}`, 'error');
            }
        }

        async function testRouter(type, address) {
            const statusId = `status-${type}-${address}`;
            const statusEl = document.getElementById(statusId);

            if (!statusEl) return;

            statusEl.className = 'router-status testing';
            statusEl.textContent = '‚è≥ Testing...';

            const diagnostics = {
                router: address,
                type: type,
                tests: [],
                failureReason: null,
                success: false
            };

            try {
                const weth = await contract.WETH();
                const testAmount = ethers.utils.parseEther('0.001');

                if (type === 'v2') {
                    // Test V2 router with actual pool verification
                    const router = new ethers.Contract(
                        address,
                        [
                            'function getAmountsOut(uint amountIn, address[] memory path) external view returns (uint[] memory amounts)',
                            'function factory() external view returns (address)'
                        ],
                        provider
                    );

                    // Test 1: Check if router contract exists
                    diagnostics.tests.push({ name: 'Contract Exists', status: 'checking' });
                    try {
                        const code = await provider.getCode(address);
                        if (code === '0x' || code === '0x0') {
                            diagnostics.tests[0].status = 'failed';
                            diagnostics.failureReason = 'No contract deployed at this address';
                            throw new Error('No contract at address');
                        }
                        diagnostics.tests[0].status = 'passed';
                    } catch (e) {
                        diagnostics.tests[0].status = 'failed';
                        diagnostics.failureReason = 'Contract does not exist at this address';
                        throw e;
                    }

                    // Test 2: Check if router has factory function
                    diagnostics.tests.push({ name: 'Factory Function', status: 'checking' });
                    let factory;
                    try {
                        factory = await router.factory();
                        diagnostics.tests[1].status = 'passed';
                        diagnostics.tests[1].factoryAddress = factory;
                    } catch (e) {
                        diagnostics.tests[1].status = 'failed';
                        diagnostics.failureReason = 'Router does not implement factory() - not a valid V2 router';
                        console.error(`V2 Router ${address} diagnostic:`, diagnostics);
                        statusEl.className = 'router-status inactive';
                        statusEl.textContent = '‚úó No Factory';
                        statusEl.title = diagnostics.failureReason;
                        showRemoveOption(type, address, diagnostics);
                        return diagnostics;
                    }

                    // Test 3: Verify factory exists
                    diagnostics.tests.push({ name: 'Factory Exists', status: 'checking' });
                    try {
                        const factoryCode = await provider.getCode(factory);
                        if (factoryCode === '0x' || factoryCode === '0x0') {
                            diagnostics.tests[2].status = 'failed';
                            diagnostics.failureReason = 'Factory contract does not exist';
                            throw new Error('Factory not deployed');
                        }
                        diagnostics.tests[2].status = 'passed';
                    } catch (e) {
                        diagnostics.tests[2].status = 'failed';
                        diagnostics.failureReason = 'Factory contract not deployed';
                        throw e;
                    }

                    // Test 4: Check if actual pool exists with liquidity
                    diagnostics.tests.push({ name: 'Pool Validation', status: 'checking' });
                    const factoryContract = new ethers.Contract(
                        factory,
                        ['function getPair(address tokenA, address tokenB) external view returns (address pair)'],
                        provider
                    );

                    try {
                        const pair = await factoryContract.getPair(weth, weth);
                        if (!pair || pair === '0x0000000000000000000000000000000000000000') {
                            diagnostics.tests[3].status = 'failed';
                            diagnostics.failureReason = 'No WETH/WETH pair exists in factory';
                            throw new Error('No pair found');
                        }

                        // Check if pair has reserves
                        const pairContract = new ethers.Contract(
                            pair,
                            ['function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast)'],
                            provider
                        );

                        const reserves = await pairContract.getReserves();
                        if (reserves.reserve0.isZero() || reserves.reserve1.isZero()) {
                            diagnostics.tests[3].status = 'failed';
                            diagnostics.failureReason = 'Pair exists but has no liquidity';
                            throw new Error('No liquidity in pair');
                        }

                        diagnostics.tests[3].status = 'passed';
                        diagnostics.tests[3].pairAddress = pair;
                        diagnostics.tests[3].reserves = [reserves.reserve0.toString(), reserves.reserve1.toString()];
                    } catch (e) {
                        diagnostics.tests[3].status = 'failed';
                        if (!diagnostics.failureReason) {
                            diagnostics.failureReason = `Pool validation failed: ${e.message}`;
                        }
                        console.error(`V2 Router ${address} diagnostic:`, diagnostics);
                        statusEl.className = 'router-status inactive';
                        statusEl.textContent = '‚úó No Liquidity';
                        statusEl.title = diagnostics.failureReason;
                        showRemoveOption(type, address, diagnostics);
                        return diagnostics;
                    }

                    // Test 5: Try getAmountsOut call
                    diagnostics.tests.push({ name: 'Quote Test', status: 'checking' });
                    const path = [weth, weth];
                    try {
                        const amounts = await router.getAmountsOut(testAmount, path);
                        if (amounts && amounts.length > 0) {
                            diagnostics.tests[4].status = 'passed';
                            diagnostics.tests[4].output = amounts.map(a => a.toString());
                            diagnostics.success = true;
                            statusEl.className = 'router-status active';
                            statusEl.textContent = '‚úì Active';
                            statusEl.title = 'All tests passed - pool has liquidity';
                        } else {
                            diagnostics.tests[4].status = 'failed';
                            diagnostics.failureReason = 'getAmountsOut returned empty/invalid result';
                            throw new Error('Invalid amounts returned');
                        }
                    } catch (e) {
                        diagnostics.tests[4].status = 'failed';
                        diagnostics.tests[4].error = e.message;

                        // Detailed error analysis
                        if (e.message.includes('INSUFFICIENT_LIQUIDITY')) {
                            diagnostics.failureReason = 'No liquidity pools available for test path';
                        } else if (e.message.includes('revert')) {
                            diagnostics.failureReason = 'Router reverted - possibly incompatible or broken';
                        } else if (e.code === 'CALL_EXCEPTION') {
                            diagnostics.failureReason = 'Call failed - router may not support this token pair';
                        } else {
                            diagnostics.failureReason = `Query failed: ${e.message}`;
                        }

                        console.error(`V2 Router ${address} diagnostic:`, diagnostics);
                        statusEl.className = 'router-status inactive';
                        statusEl.textContent = '‚úó Failed';
                        statusEl.title = diagnostics.failureReason;
                        showRemoveOption(type, address, diagnostics);
                        return diagnostics;
                    }

                } else {
                    // Test V3 router
                    // Test 1: Check if router contract exists
                    diagnostics.tests.push({ name: 'Contract Exists', status: 'checking' });
                    try {
                        const code = await provider.getCode(address);
                        if (code === '0x' || code === '0x0') {
                            diagnostics.tests[0].status = 'failed';
                            diagnostics.failureReason = 'No contract deployed at this address';
                            throw new Error('No contract at address');
                        }
                        diagnostics.tests[0].status = 'passed';
                    } catch (e) {
                        diagnostics.tests[0].status = 'failed';
                        throw e;
                    }

                    // Test 2: Check factory mapping
                    diagnostics.tests.push({ name: 'Factory Mapping', status: 'checking' });
                    const factory = await contract.v3RouterToFactory(address);
                    if (factory === '0x0000000000000000000000000000000000000000') {
                        diagnostics.tests[1].status = 'failed';
                        diagnostics.failureReason = 'No factory configured in contract for this V3 router';
                        console.error(`V3 Router ${address} diagnostic:`, diagnostics);
                        statusEl.className = 'router-status inactive';
                        statusEl.textContent = '‚úó No Factory';
                        statusEl.title = diagnostics.failureReason;
                        showRemoveOption(type, address, diagnostics);
                        return diagnostics;
                    }
                    diagnostics.tests[1].status = 'passed';
                    diagnostics.tests[1].factoryAddress = factory;

                    // Test 3: Verify factory exists
                    diagnostics.tests.push({ name: 'Factory Exists', status: 'checking' });
                    try {
                        const factoryCode = await provider.getCode(factory);
                        if (factoryCode === '0x' || factoryCode === '0x0') {
                            diagnostics.tests[2].status = 'failed';
                            diagnostics.failureReason = 'Factory contract does not exist';
                            throw new Error('Factory not deployed');
                        }
                        diagnostics.tests[2].status = 'passed';
                    } catch (e) {
                        diagnostics.tests[2].status = 'failed';
                        throw e;
                    }

                    // Test 4: Try to get pools from factory
                    diagnostics.tests.push({ name: 'Pool Query', status: 'checking' });
                    const factoryContract = new ethers.Contract(
                        factory,
                        ['function getPool(address tokenA, address tokenB, uint24 fee) external view returns (address pool)'],
                        provider
                    );

                    let hasValidPool = false;
                    const feeTiers = [500, 3000, 10000];
                    const poolResults = [];

                    for (const fee of feeTiers) {
                        try {
                            const pool = await factoryContract.getPool(weth, weth, fee);
                            poolResults.push({ fee, pool });
                            if (pool && pool !== '0x0000000000000000000000000000000000000000') {
                                hasValidPool = true;
                            }
                        } catch (e) {
                            poolResults.push({ fee, error: e.message });
                        }
                    }

                    diagnostics.tests[3].poolResults = poolResults;

                    if (hasValidPool) {
                        diagnostics.tests[3].status = 'passed';
                        diagnostics.success = true;
                        statusEl.className = 'router-status active';
                        statusEl.textContent = '‚úì Active';
                        statusEl.title = 'All tests passed - pools found';
                    } else {
                        diagnostics.tests[3].status = 'warning';
                        diagnostics.failureReason = 'Factory exists but no liquidity pools found for test tokens';
                        diagnostics.success = true; // Still mark as success since factory is valid
                        statusEl.className = 'router-status active';
                        statusEl.textContent = '‚ö† No Pools';
                        statusEl.title = diagnostics.failureReason;
                    }
                }

                console.log(`Router ${address} diagnostic:`, diagnostics);
                return diagnostics;

            } catch (error) {
                console.error(`Router test failed for ${address}:`, error);
                if (!diagnostics.failureReason) {
                    diagnostics.failureReason = `Unexpected error: ${error.message}`;
                }
                statusEl.className = 'router-status inactive';
                statusEl.textContent = '‚úó Failed';
                statusEl.title = diagnostics.failureReason;
                showRemoveOption(type, address, diagnostics);
                console.log(`Router ${address} diagnostic:`, diagnostics);
                return diagnostics;
            }
        }

        function showRemoveOption(type, address, diagnostics) {
            // Highlight the remove button for failed routers
            const routerItem = document.getElementById(`${type}-${address}`);
            if (routerItem) {
                const removeBtn = routerItem.querySelector('.btn-danger');
                if (removeBtn) {
                    removeBtn.style.backgroundColor = '#ff4444';
                    removeBtn.style.animation = 'pulse 1s infinite';
                    removeBtn.textContent = '‚ö† Remove Failed Router';
                }

                // Add diagnostics display
                if (diagnostics) {
                    let diagHtml = `<div style="margin-top: 10px; padding: 10px; background: #fff3cd; border-radius: 5px; font-size: 0.9em;">`;
                    diagHtml += `<strong>Failure Reason:</strong> ${diagnostics.failureReason}<br>`;
                    diagHtml += `<strong>Tests:</strong><ul style="margin: 5px 0; padding-left: 20px;">`;

                    diagnostics.tests.forEach(test => {
                        const icon = test.status === 'passed' ? '‚úì' : test.status === 'failed' ? '‚úó' : '‚ö†';
                        diagHtml += `<li>${icon} ${test.name}`;
                        if (test.factoryAddress) diagHtml += ` (${test.factoryAddress.slice(0, 10)}...)`;
                        if (test.error) diagHtml += ` - ${test.error}`;
                        diagHtml += `</li>`;
                    });

                    diagHtml += `</ul></div>`;

                    // Remove old diagnostics if exists
                    const oldDiag = routerItem.querySelector('.router-diagnostics');
                    if (oldDiag) oldDiag.remove();

                    const diagDiv = document.createElement('div');
                    diagDiv.className = 'router-diagnostics';
                    diagDiv.innerHTML = diagHtml;
                    routerItem.appendChild(diagDiv);
                }
            }
        }

        async function testAllRouters() {
            try {
                const v2Routers = await contract.getRouters();
                const v3Routers = await contract.getV3Routers();

                showMessage('routerMessage', `Testing ${v2Routers.length} V2 and ${v3Routers.length} V3 routers...`, 'info');

                let failedV2 = 0;
                let failedV3 = 0;

                // Test all V2 routers
                for (const router of v2Routers) {
                    await testRouter('v2', router);
                    // Small delay to avoid rate limiting
                    await new Promise(resolve => setTimeout(resolve, 100));

                    const statusEl = document.getElementById(`status-v2-${router}`);
                    if (statusEl && statusEl.textContent.includes('‚úó')) {
                        failedV2++;
                    }
                }

                // Test all V3 routers
                for (const router of v3Routers) {
                    await testRouter('v3', router);
                    await new Promise(resolve => setTimeout(resolve, 100));

                    const statusEl = document.getElementById(`status-v3-${router}`);
                    if (statusEl && statusEl.textContent.includes('‚úó')) {
                        failedV3++;
                    }
                }

                const totalFailed = failedV2 + failedV3;
                const totalTested = v2Routers.length + v3Routers.length;
                const successCount = totalTested - totalFailed;

                if (totalFailed > 0) {
                    showMessage('routerMessage', 
                        `Testing complete: ${successCount}/${totalTested} routers working. ` +
                        `${failedV2} V2 and ${failedV3} V3 routers failed. Consider removing failed routers.`, 
                        'error');
                } else {
                    showMessage('routerMessage', `All ${totalTested} routers tested successfully! ‚úì`, 'success');
                }
            } catch (error) {
                console.error('Error testing routers:', error);
                showMessage('routerMessage', `Error: ${error.message}`, 'error');
            }
        }

        function confirmRemoveRouter(type, address) {
            const statusEl = document.getElementById(`status-${type}-${address}`);
            const status = statusEl ? statusEl.textContent : 'Unknown';

            const confirmed = confirm(
                `Are you sure you want to remove this ${type.toUpperCase()} router?\n\n` +
                `Address: ${address}\n` +
                `Status: ${status}\n\n` +
                `This action cannot be undone.`
            );

            if (confirmed) {
                removeRouter(type, address);
            }
        }

        async function removeRouter(type, address) {
            try {
                showMessage('routerMessage', 'Removing router...', 'info');
                const tx = type === 'v2' ? 
                    await contract.removeRouter(address) : 
                    await contract.removeV3Router(address);

                await tx.wait();
                showMessage('routerMessage', 'Router removed successfully!', 'success');
                await loadRouters();
            } catch (error) {
                console.error('Error removing router:', error);
                showMessage('routerMessage', `Error: ${error.message}`, 'error');
            }
        }


        async function removeAllFailedRouters() {
            try {
                const v2Routers = await contract.getRouters();
                const v3Routers = await contract.getV3Routers();

                const failedV2 = [];
                const failedV3 = [];

                // Check V2 routers
                for (const router of v2Routers) {
                    const statusEl = document.getElementById(`status-v2-${router}`);
                    if (statusEl && statusEl.textContent.includes('‚úó')) {
                        failedV2.push(router);
                    }
                }

                // Check V3 routers
                for (const router of v3Routers) {
                    const statusEl = document.getElementById(`status-v3-${router}`);
                    if (statusEl && statusEl.textContent.includes('‚úó')) {
                        failedV3.push(router);
                    }
                }

                const totalFailed = failedV2.length + failedV3.length;

                if (totalFailed === 0) {
                    showMessage('routerMessage', 'No failed routers to remove. Test routers first!', 'info');
                    return;
                }

                const confirmed = confirm(
                    `Found ${totalFailed} failed router(s):\n\n` +
                    `V2: ${failedV2.length}\n` +
                    `V3: ${failedV3.length}\n\n` +
                    `Remove all failed routers?`
                );

                if (!confirmed) return;

                showMessage('routerMessage', `Removing ${totalFailed} failed routers...`, 'info');

                let removed = 0;

                // Remove failed V2 routers
                for (const router of failedV2) {
                    try {
                        const tx = await contract.removeRouter(router);
                        await tx.wait();
                        removed++;
                    } catch (error) {
                        console.error(`Failed to remove V2 router ${router}:`, error);
                    }
                }

                // Remove failed V3 routers
                for (const router of failedV3) {
                    try {
                        const tx = await contract.removeV3Router(router);
                        await tx.wait();
                        removed++;
                    } catch (error) {
                        console.error(`Failed to remove V3 router ${router}:`, error);
                    }
                }

                showMessage('routerMessage', `Successfully removed ${removed}/${totalFailed} failed routers!`, 'success');
                await loadRouters();

            } catch (error) {
                console.error('Error removing failed routers:', error);
                showMessage('routerMessage', `Error: ${error.message}`, 'error');
            }
        }


        async function withdrawFees() {
            try {
                showMessage('configMessage', 'Withdrawing fees...', 'info');
                const tx = await contract.withdrawFees();
                await tx.wait();
                showMessage('configMessage', 'Fees withdrawn successfully!', 'success');
            } catch (error) {
                console.error('Error withdrawing fees:', error);
                showMessage('configMessage', `Error: ${error.message}`, 'error');
            }
        }

        async function debugQuote() {
            const tokenIn = document.getElementById('tokenIn').value;
            const tokenOut = document.getElementById('tokenOut').value;
            const amountIn = document.getElementById('amountIn').value;

            if (!ethers.utils.isAddress(tokenIn) || !ethers.utils.isAddress(tokenOut)) {
                showMessage('swapMessage', 'Invalid token addresses', 'error');
                return;
            }

            try {
                showMessage('swapMessage', 'Calling contract debug function...', 'info');
                const result = await contract.debugGetQuote(
                    ethers.utils.parseUnits(amountIn || '1', 18),
                    [tokenIn, tokenOut]
                );
                
                let debugHtml = '<div style="background: #e3f2fd; padding: 15px; border-radius: 8px; margin-bottom: 15px; border-left: 4px solid #1976d2;">';
                debugHtml += '<h4 style="margin: 0 0 10px 0; color: #1565c0;">üîç Contract Debug Info</h4>';
                debugHtml += '<ul style="margin: 5px 0; padding-left: 20px; font-family: monospace;">';
                debugHtml += `<li><strong>V2 Best Output:</strong> ${result.v2BestOut.toString()}</li>`;
                debugHtml += `<li><strong>V3 Best Output:</strong> ${result.v3BestOut.toString()}</li>`;
                debugHtml += `<li><strong>Final Best Output:</strong> ${result.finalBestOut.toString()}</li>`;
                debugHtml += `<li><strong>Best Router:</strong> ${result.finalBestRouter}</li>`;
                debugHtml += `<li><strong>Decision:</strong> ${result.debugInfo}</li>`;
                debugHtml += '</ul></div>';
                
                document.getElementById('quoteResult').innerHTML = debugHtml;
                showMessage('swapMessage', 'Debug info retrieved!', 'success');
            } catch (error) {
                showMessage('swapMessage', `Debug Error: ${error.message}`, 'error');
            }
        }

        async function getQuote() {
            const tokenIn = document.getElementById('tokenIn').value;
            const tokenOut = document.getElementById('tokenOut').value;
            const amountIn = document.getElementById('amountIn').value;

            if (!ethers.utils.isAddress(tokenIn) || !ethers.utils.isAddress(tokenOut)) {
                showMessage('swapMessage', 'Invalid token addresses', 'error');
                return;
            }

            if (!amountIn || amountIn <= 0) {
                showMessage('swapMessage', 'Invalid amount', 'error');
                return;
            }

            const diagnostics = {
                tokenIn,
                tokenOut,
                amountIn,
                checks: [],
                routerResults: [],
                failureReason: null,
                success: false
            };

            try {
                showMessage('swapMessage', 'Running diagnostics and fetching quote...', 'info');

                // Check 1: Verify routers exist
                diagnostics.checks.push({ name: 'Router Configuration', status: 'checking' });
                const v2Routers = await contract.getRouters();
                const v3Routers = await contract.getV3Routers();

                if (v2Routers.length === 0 && v3Routers.length === 0) {
                    diagnostics.checks[0].status = 'failed';
                    diagnostics.failureReason = 'No routers configured. Please add routers in the Router Management tab.';
                    throw new Error('No routers');
                }
                diagnostics.checks[0].status = 'passed';
                diagnostics.checks[0].v2Count = v2Routers.length;
                diagnostics.checks[0].v3Count = v3Routers.length;

                // Check 2: Verify V3 factories
                diagnostics.checks.push({ name: 'V3 Factory Validation', status: 'checking' });
                const v3FactoryIssues = [];
                for (let i = 0; i < v3Routers.length; i++) {
                    const factory = await contract.v3RouterToFactory(v3Routers[i]);
                    if (factory === '0x0000000000000000000000000000000000000000') {
                        v3FactoryIssues.push(v3Routers[i]);
                    }
                }
                if (v3FactoryIssues.length > 0) {
                    diagnostics.checks[1].status = 'warning';
                    diagnostics.checks[1].issues = v3FactoryIssues;
                } else {
                    diagnostics.checks[1].status = 'passed';
                }

                // Check 3: Test each router individually
                diagnostics.checks.push({ name: 'Individual Router Tests', status: 'checking' });

                for (const router of v2Routers) {
                    try {
                        const routerContract = new ethers.Contract(
                            router,
                            ['function getAmountsOut(uint amountIn, address[] memory path) external view returns (uint[] memory amounts)'],
                            provider
                        );
                        const amounts = await routerContract.getAmountsOut(amountIn, [tokenIn, tokenOut]);
                        diagnostics.routerResults.push({
                            router,
                            type: 'V2',
                            status: 'success',
                            output: amounts[amounts.length - 1].toString()
                        });
                    } catch (e) {
                        diagnostics.routerResults.push({
                            router,
                            type: 'V2',
                            status: 'failed',
                            error: e.message.includes('INSUFFICIENT_LIQUIDITY') ? 'No liquidity' : 
                                   e.message.includes('revert') ? 'Contract reverted' :
                                   e.code === 'CALL_EXCEPTION' ? 'Invalid pair' : e.message
                        });
                    }
                }

                for (const router of v3Routers) {
                    const factory = await contract.v3RouterToFactory(router);
                    if (factory === '0x0000000000000000000000000000000000000000') {
                        diagnostics.routerResults.push({
                            router,
                            type: 'V3',
                            status: 'failed',
                            error: 'No factory configured'
                        });
                        continue;
                    }

                    try {
                        const factoryContract = new ethers.Contract(
                            factory,
                            ['function getPool(address tokenA, address tokenB, uint24 fee) external view returns (address pool)'],
                            provider
                        );

                        const feeTiers = [
                            { fee: 100, label: '0.01%' },
                            { fee: 500, label: '0.05%' },
                            { fee: 3000, label: '0.3%' },
                            { fee: 10000, label: '1%' }
                        ];
                        
                        const v3ResultDetail = {
                            router,
                            type: 'V3',
                            factory,
                            feeTiersChecked: []
                        };
                        
                        let bestPool = null;
                        let bestFee = null;
                        let bestLiquidity = null;

                        for (const {fee, label} of feeTiers) {
                            const tierResult = { fee, label, poolExists: false, details: '' };
                            
                            try {
                                const pool = await factoryContract.getPool(tokenIn, tokenOut, fee);
                                if (pool && pool !== '0x0000000000000000000000000000000000000000') {
                                    tierResult.poolAddress = pool;
                                    tierResult.poolExists = true;
                                    
                                    // Try to get pool details
                                    try {
                                        const poolContract = new ethers.Contract(
                                            pool,
                                            ['function liquidity() external view returns (uint128)',
                                             'function slot0() external view returns (uint160 sqrtPriceX96, int24 tick, uint16 observationIndex, uint16 observationCardinality, uint16 observationCardinalityNext, uint8 feeProtocol, bool unlocked)',
                                             'function token0() external view returns (address)',
                                             'function token1() external view returns (address)'],
                                            provider
                                        );
                                        
                                        const liquidity = await poolContract.liquidity();
                                        const slot0 = await poolContract.slot0();
                                        const token0 = await poolContract.token0();
                                        const token1 = await poolContract.token1();
                                        
                                        tierResult.liquidity = liquidity.toString();
                                        tierResult.sqrtPrice = slot0.sqrtPriceX96.toString();
                                        tierResult.tick = slot0.tick.toString();
                                        tierResult.unlocked = slot0.unlocked;
                                        tierResult.tokenOrder = `${token0 === tokenIn ? 'Correct' : 'Reversed'}`;
                                        
                                        if (liquidity.gt(0)) {
                                            tierResult.details = `‚úì Active pool with ${liquidity.toString().slice(0, 8)}... liquidity`;
                                            if (!bestPool || liquidity.gt(bestLiquidity)) {
                                                bestPool = pool;
                                                bestFee = fee;
                                                bestLiquidity = liquidity;
                                            }
                                        } else {
                                            tierResult.details = '‚ö† Pool exists but has NO liquidity';
                                        }
                                    } catch (poolErr) {
                                        tierResult.details = `‚úì Pool found at ${pool.slice(0,10)}... (details error: ${poolErr.message.slice(0, 30)})`;
                                    }
                                } else {
                                    tierResult.details = '‚úó No pool at this fee tier';
                                }
                            } catch (feeErr) {
                                tierResult.details = `‚úó Error checking fee tier: ${feeErr.message.slice(0, 50)}`;
                            }
                            
                            v3ResultDetail.feeTiersChecked.push(tierResult);
                        }

                        if (bestPool) {
                            diagnostics.routerResults.push({
                                router,
                                type: 'V3',
                                status: 'success',
                                pool: bestPool,
                                fee: bestFee,
                                liquidity: bestLiquidity.toString(),
                                allTiers: v3ResultDetail.feeTiersChecked
                            });
                        } else {
                            // No liquidity found in any tier
                            diagnostics.routerResults.push({
                                ...v3ResultDetail,
                                status: 'failed',
                                error: 'No pools with liquidity found in any fee tier',
                                allTiers: v3ResultDetail.feeTiersChecked
                            });
                        }
                    } catch (e) {
                        diagnostics.routerResults.push({
                            router,
                            type: 'V3',
                            status: 'failed',
                            error: `Factory error: ${e.message}`
                        });
                    }
                }

                const successfulRouters = diagnostics.routerResults.filter(r => r.status === 'success');
                if (successfulRouters.length === 0) {
                    diagnostics.checks[2].status = 'failed';
                    diagnostics.failureReason = 'No routers found valid liquidity for this token pair';
                    throw new Error('No valid routes');
                }
                diagnostics.checks[2].status = 'passed';
                diagnostics.checks[2].successCount = successfulRouters.length;

                const slippage = parseFloat(document.getElementById('slippage').value);
                const slippageBPS = Math.floor(slippage * 100);
                const path = [tokenIn, tokenOut];

                console.log('Getting quote for:', {
                    amountIn,
                    path,
                    slippageBPS,
                    v2Routers: v2Routers.length,
                    v3Routers: v3Routers.length,
                    diagnostics
                });

                // Check 4: Call contract's getBestSwapData
                diagnostics.checks.push({ name: 'Contract Quote', status: 'checking' });
                diagnostics.checks[3].contractParams = {
                    amountIn: amountIn.toString(),
                    path: path,
                    supportFeeOnTransfer: false,
                    slippageBPS: slippageBPS
                };
                
                let swapData;
                try {
                    swapData = await contract.getBestSwapData(
                        amountIn,
                        path,
                        false,
                        slippageBPS
                    );
                    diagnostics.checks[3].status = 'passed';
                    diagnostics.success = true;
                } catch (contractError) {
                    // Detailed error capturing
                    diagnostics.checks[3].status = 'failed';
                    
                    // Parse error message
                    let errorMsg = contractError.message || 'Unknown error';
                    let revertReason = 'Contract execution failed';
                    
                    // Try to extract revert reason from error
                    if (contractError.data) {
                        try {
                            const iface = new ethers.utils.Interface(['function Error(string)']);
                            const decodedError = iface.parseError(contractError.data);
                            if (decodedError) revertReason = decodedError.args[0];
                        } catch (e) {}
                    }
                    
                    // Try ethers error decoding
                    if (errorMsg.includes('revert')) {
                        const revertMatch = errorMsg.match(/revert (.*?)($|,)/);
                        if (revertMatch) revertReason = revertMatch[1];
                    }
                    
                    diagnostics.checks[3].error = {
                        message: errorMsg,
                        reason: revertReason,
                        code: contractError.code,
                        data: contractError.data ? contractError.data.slice(0, 100) : null
                    };
                    
                    // Detailed diagnostic message
                    const detailedError = `Contract Error: ${revertReason}\n\nDetails:\n- Error Code: ${contractError.code || 'Unknown'}\n- Message: ${errorMsg.slice(0, 150)}`;
                    diagnostics.failureReason = detailedError;
                    
                    throw new Error(detailedError);
                }

                currentQuote = swapData;

                const routerTypeText = swapData.routerType === 0 ? 'Uniswap V2' : 'Uniswap V3';

                // Display diagnostics
                let diagHtml = '<div style="background: #e8f5e9; padding: 15px; border-radius: 8px; margin-bottom: 15px;">';
                diagHtml += '<h4 style="margin: 0 0 10px 0; color: #2e7d32;">‚úì Diagnostics Passed</h4>';
                diagHtml += `<p style="margin: 5px 0;"><strong>Routers tested:</strong> ${diagnostics.routerResults.length}</p>`;
                diagHtml += `<p style="margin: 5px 0;"><strong>Successful routes:</strong> ${successfulRouters.length}</p>`;
                
                // Show detailed info about selected router
                const selectedRoute = diagnostics.routerResults.find(r => r.router === swapData.router);
                if (selectedRoute) {
                    if (selectedRoute.type === 'V3' && selectedRoute.liquidity) {
                        diagHtml += `<p style="margin: 5px 0;"><strong>V3 Pool Liquidity:</strong> ${selectedRoute.liquidity.slice(0, 15)}...</p>`;
                        if (selectedRoute.allTiers) {
                            const activeTier = selectedRoute.allTiers.find(t => t.poolExists && t.liquidity && t.liquidity !== '0');
                            if (activeTier) {
                                diagHtml += `<p style="margin: 5px 0;"><strong>Fee Tier Used:</strong> ${activeTier.label}</p>`;
                            }
                        }
                    }
                }
                
                diagHtml += '</div>';

                document.getElementById('quoteResult').innerHTML = diagHtml + `
                    <div class="quote-card">
                        <h3 style="margin-bottom: 15px; color: #667eea;">Best Quote Found</h3>
                        <div class="quote-row">
                            <span class="quote-label">Router:</span>
                            <span class="quote-value">${swapData.router}</span>
                        </div>
                        <div class="quote-row">
                            <span class="quote-label">Type:</span>
                            <span class="quote-value">${routerTypeText}</span>
                        </div>
                        <div class="quote-row">
                            <span class="quote-label">Amount In:</span>
                            <span class="quote-value">${swapData.amountIn.toString()}</span>
                        </div>
                        <div class="quote-row">
                            <span class="quote-label">Min Amount Out:</span>
                            <span class="quote-value">${swapData.amountOutMin.toString()}</span>
                        </div>
                        <div class="quote-row">
                            <span class="quote-label">Path:</span>
                            <span class="quote-value">${swapData.path.join(' ‚Üí ')}</span>
                        </div>
                        ${swapData.routerType === 1 && swapData.v3Fees.length > 0 ? `
                        <div class="quote-row">
                            <span class="quote-label">V3 Fees:</span>
                            <span class="quote-value">${swapData.v3Fees.map(f => `${f / 10000}%`).join(', ')}</span>
                        </div>
                        ` : ''}
                        <div class="quote-row">
                            <span class="quote-label">Deadline:</span>
                            <span class="quote-value">${new Date(swapData.deadline * 1000).toLocaleString()}</span>
                        </div>
                    </div>
                `;

                document.getElementById('swapFlow').innerHTML = `
                    <button class="btn btn-success" onclick="executeSwapFlow()">
                        Execute Swap
                    </button>
                `;

                showMessage('swapMessage', 'Quote retrieved successfully!', 'success');
                console.log('Quote diagnostics:', diagnostics);

            } catch (error) {
                console.error('Error getting quote:', error);
                console.log('Failed diagnostics:', diagnostics);

                // Display detailed diagnostics
                let diagHtml = '<div style="background: #ffebee; padding: 15px; border-radius: 8px; margin: 15px 0;">';
                diagHtml += '<h4 style="margin: 0 0 10px 0; color: #c62828;">‚úó Quote Failed - Diagnostics</h4>';

                // Show contract error details if available
                const contractCheck = diagnostics.checks && diagnostics.checks[3];
                if (contractCheck && contractCheck.error) {
                    diagHtml += '<div style="background: #ffcccc; padding: 12px; border-radius: 5px; margin-bottom: 15px; border-left: 4px solid #d32f2f;">';
                    diagHtml += `<p style="margin: 5px 0; font-weight: bold; color: #c62828;">üî¥ Contract Quote Failed</p>`;
                    diagHtml += `<p style="margin: 5px 0; font-family: monospace; font-size: 0.85em; color: #333;"><strong>Reason:</strong> ${contractCheck.error.reason}</p>`;
                    diagHtml += `<p style="margin: 5px 0; font-family: monospace; font-size: 0.85em; color: #333;"><strong>Error Code:</strong> ${contractCheck.error.code || 'Unknown'}</p>`;
                    if (contractCheck.error.message) {
                        diagHtml += `<p style="margin: 5px 0; font-family: monospace; font-size: 0.85em; color: #555;"><strong>Details:</strong> ${contractCheck.error.message.slice(0, 200)}</p>`;
                    }
                    diagHtml += '</div>';
                    
                    // Show parameters that were sent
                    if (contractCheck.contractParams) {
                        diagHtml += '<div style="background: #fff9c4; padding: 12px; border-radius: 5px; margin-bottom: 15px;">';
                        diagHtml += '<p style="margin: 5px 0; font-weight: bold; color: #333;">Contract Parameters Sent:</p>';
                        diagHtml += '<ul style="margin: 5px 0; padding-left: 20px; font-size: 0.9em; font-family: monospace;">';
                        diagHtml += `<li><strong>Amount In:</strong> ${contractCheck.contractParams.amountIn}</li>`;
                        diagHtml += `<li><strong>Path:</strong> [${contractCheck.contractParams.path.map(p => p.slice(0, 8) + '...').join(', ')}]</li>`;
                        diagHtml += `<li><strong>Slippage (BPS):</strong> ${contractCheck.contractParams.slippageBPS} (${(contractCheck.contractParams.slippageBPS / 100).toFixed(2)}%)</li>`;
                        diagHtml += `<li><strong>Support Fee-on-Transfer:</strong> ${contractCheck.contractParams.supportFeeOnTransfer}</li>`;
                        diagHtml += '</ul>';
                        diagHtml += '</div>';
                    }
                }

                if (diagnostics.failureReason && !contractCheck?.error) {
                    diagHtml += `<p style="margin: 10px 0; font-weight: bold; color: #c62828;">${diagnostics.failureReason}</p>`;
                }

                diagHtml += '<div style="margin-top: 15px;"><strong>Diagnostic Checks:</strong><ul style="margin: 5px 0; padding-left: 20px;">';
                diagnostics.checks.forEach(check => {
                    const icon = check.status === 'passed' ? '‚úì' : check.status === 'failed' ? '‚úó' : '‚ö†';
                    diagHtml += `<li>${icon} ${check.name}`;
                    if (check.v2Count !== undefined) diagHtml += ` (V2: ${check.v2Count}, V3: ${check.v3Count})`;
                    if (check.successCount !== undefined) diagHtml += ` (${check.successCount} successful)`;
                    if (check.issues) diagHtml += ` - ${check.issues.length} routers with issues`;
                    diagHtml += '</li>';
                });
                diagHtml += '</ul></div>';

                if (diagnostics.routerResults.length > 0) {
                    diagHtml += '<div style="margin-top: 15px;"><strong>Router Test Results:</strong><ul style="margin: 5px 0; padding-left: 20px;">';
                    diagnostics.routerResults.forEach(result => {
                        const icon = result.status === 'success' ? '‚úì' : '‚úó';
                        diagHtml += `<li>${icon} ${result.type} Router ${result.router.slice(0, 10)}...`;
                        
                        if (result.error) {
                            diagHtml += ` - <span style="color: #c62828;"><strong>${result.error}</strong></span>`;
                        }
                        
                        if (result.output) {
                            diagHtml += ` - Output: ${result.output}`;
                        }
                        
                        if (result.pool) {
                            diagHtml += ` - Pool: ${result.pool.slice(0, 10)}... (Fee: ${result.fee / 10000}%)`;
                            if (result.liquidity) diagHtml += ` - Liquidity: ${result.liquidity.slice(0, 10)}...`;
                        }
                        
                        // Show V3 fee tier details if present
                        if (result.allTiers && result.allTiers.length > 0) {
                            diagHtml += '<ul style="margin: 5px 5px; padding-left: 20px; border-left: 2px solid #667eea;">';
                            result.allTiers.forEach(tier => {
                                const tierIcon = tier.poolExists ? '‚úì' : '‚úó';
                                diagHtml += `<li style="font-size: 0.9em;"><strong>${tierIcon} Fee ${tier.label}</strong>: `;
                                
                                if (tier.poolExists && tier.liquidity) {
                                    const liqStr = tier.liquidity.slice(0, 15);
                                    diagHtml += `Pool: ${tier.poolAddress.slice(0, 8)}... | Liquidity: ${liqStr}... | `;
                                    diagHtml += `Price (sqrtX96): ${tier.sqrtPrice.slice(0, 10)}... | `;
                                    diagHtml += `Tick: ${tier.tick} | `;
                                    diagHtml += `Token Order: ${tier.tokenOrder}`;
                                }
                                
                                if (tier.details) {
                                    diagHtml += tier.details;
                                }
                                
                                diagHtml += '</li>';
                            });
                            diagHtml += '</ul>';
                        }
                        
                        diagHtml += '</li>';
                    });
                    diagHtml += '</ul></div>';
                }

                diagHtml += '<div style="margin-top: 15px; padding: 10px; background: #fff3cd; border-radius: 5px;">';
                diagHtml += '<strong>Suggestions:</strong><ul style="margin: 5px 0; padding-left: 20px;">';
                diagHtml += '<li>Verify token addresses are correct</li>';
                diagHtml += '<li>Check if liquidity pools exist for this pair</li>';
                diagHtml += '<li>Try testing routers in the Router Management tab</li>';
                diagHtml += '<li>Add more routers if available</li>';
                diagHtml += '</ul></div>';

                diagHtml += '</div>';

                document.getElementById('quoteResult').innerHTML = diagHtml;

                showMessage('swapMessage', diagnostics.failureReason || 'Failed to get quote - see diagnostics above', 'error');
            }
        }

        async function executeSwapFlow() {
            if (!currentQuote) {
                showMessage('swapMessage', 'No quote available. Please get a quote first.', 'error');
                return;
            }

            const tokenIn = currentQuote.path[0];
            const isETHSwap = currentQuote.swapType === 0; // ETH_TO_TOKEN

            // Show flow
            document.getElementById('swapFlow').innerHTML = `
                <div class="swap-flow">
                    <div class="step-indicator" id="step1">
                        <div class="step-number">1</div>
                        <div>Check Token Allowance</div>
                    </div>
                    <div class="step-indicator" id="step2">
                        <div class="step-number">2</div>
                        <div>Approve Token (if needed)</div>
                    </div>
                    <div class="step-indicator" id="step3">
                        <div class="step-number">3</div>
                        <div>Execute Swap</div>
                    </div>
                </div>
            `;

            try {
                // Step 1 & 2: Only for token swaps (not ETH)
                if (!isETHSwap) {
                    document.getElementById('step1').classList.add('active');
                    showMessage('swapMessage', 'Checking token allowance...', 'info');

                    const tokenContract = new ethers.Contract(tokenIn, ERC20_ABI, signer);
                    const allowance = await tokenContract.allowance(userAddress, contractConfig.contractAddress);

                    document.getElementById('step1').classList.remove('active');
                    document.getElementById('step1').classList.add('completed');

                    if (allowance.lt(currentQuote.amountIn)) {
                        document.getElementById('step2').classList.add('active');
                        showMessage('swapMessage', 'Approval needed. Please confirm the transaction...', 'info');

                        const approveTx = await tokenContract.approve(
                            contractConfig.contractAddress, 
                            ethers.constants.MaxUint256
                        );

                        showMessage('swapMessage', 'Waiting for approval confirmation...', 'info');
                        await approveTx.wait();

                        document.getElementById('step2').classList.remove('active');
                        document.getElementById('step2').classList.add('completed');
                        showMessage('swapMessage', 'Token approved successfully!', 'success');
                    } else {
                        document.getElementById('step2').classList.add('completed');
                        showMessage('swapMessage', 'Token already approved', 'success');
                    }
                } else {
                    document.getElementById('step1').classList.add('completed');
                    document.getElementById('step2').classList.add('completed');
                }

                // Step 3: Execute swap
                document.getElementById('step3').classList.add('active');
                showMessage('swapMessage', 'Executing swap. Please confirm the transaction...', 'info');

                const value = isETHSwap ? currentQuote.amountIn : 0;
                const swapTx = await contract.execute(currentQuote, { value });

                showMessage('swapMessage', 'Waiting for swap confirmation...', 'info');
                const receipt = await swapTx.wait();

                document.getElementById('step3').classList.remove('active');
                document.getElementById('step3').classList.add('completed');

                showMessage('swapMessage', `Swap executed successfully! Tx: ${receipt.transactionHash}`, 'success');

                // Reset quote
                currentQuote = null;
                setTimeout(() => {
                    document.getElementById('swapFlow').innerHTML = '';
                    document.getElementById('quoteResult').innerHTML = '';
                }, 5000);

            } catch (error) {
                console.error('Error executing swap:', error);
                showMessage('swapMessage', `Error: ${error.message || error}`, 'error');

                // Reset flow indicators
                document.querySelectorAll('.step-indicator').forEach(step => {
                    step.classList.remove('active');
                });
            }
        }

        function switchTab(tabName) {
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });

            document.getElementById(tabName).classList.add('active');
            event.target.classList.add('active');
        }

        function showMessage(elementId, message, type) {
            const msgEl = document.getElementById(elementId);
            msgEl.textContent = message;
            msgEl.className = `message show ${type}`;

            setTimeout(() => {
                msgEl.classList.remove('show');
            }, 5000);
        }

        window.addEventListener('load', init);
    </script>
</body>
</html>
